---
title: "Breeding bird indicators"
subtitle: |
  [NO_BIRD_001] (farmland and open lowland) \
  [NO_BIRD_002] (mountains) \
  [NO_BIRD_003] (wetlands) \
  [NO_BIRD_004] (forests)
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Chloé R. Nater
    email: chloe.nater@nina.no  # Enter email
    affiliations:
      - id: myID
        name: Norwegian Institute for Nature Research # Enter affiliations
  - name: Diego Pavón-Jordán
    affiliations:
      - ref: myID
  - name: Anders L. Kolstad
    email: anders.kolstad@nina.no  # Enter email
    affiliations:
      - ref: myID
date: February 3, 2025
callout-icon: false
lightbox: true
css: ../../../style.css
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
bibliography: references.bib
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
library(odbc)
library(rtrim)
library(data.table)
knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
source(here::here("_common.R"))
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

<!--# The following parts are autogenerated. Do not edit. -->

```{r}
#| echo: false
#| results: asis
status(st)
```

::: {layout-ncol="2"}
> **Recomended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: ", url, sep="")`

> **Version**: `r version`
:::

```{=html}
<details>
<summary>Show metadata</summary>
```

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

</details>

::: {.callout-tip collapse="true"}
## Logg

<!--# Update this logg with short messages for each update -->

-   Oct. 2023 - Complete workflow [described](https://ninanor.github.io/ecosystemCondition/breeding-birds.html)
-   3 Feb. 2025 - Started restructuring documentatoin for ecRxiv and updating indicator values
:::

<hr />

<!--# Document you work below.  -->

## 1. Summary

```{=html}
<!--# 

With a maximum of 300 words, describe the indicator in general terms as you would to a non-expert. Think of this as a kind of commmon language summary. It is a good idea to include a bullet point list of the spesific steps in the workflow. Include a mention of the following aspects:

What does the metric represent?
Why is this relevant for describing ecosystem condition in this ecosystem?
What are the main anthropogenig impact factors?
What kind of data is used? 
Shortly, how is the data customized (modified, estimated, integarted) to fit its purpuse as an indicator?
What is the current status of  the metric (can it be used or is it still in development)?
How should the metric be used and interpretted, and how should it not be used/interpretted?

 -->
```

Birds are a conspicuous part of biodiversity and well known to both laymen and to science. Birds also perform important ecosystem functions, and respond to natural and anthropogenic pressures, such as land-use change, climate change, and changes in food supply (esp. insects, but also seeds). This makes bird population sizes a very good metric for monitoring ecosystem condition. The Norwegian bird monitoring program *Hekkefulgovervåkingen* (previously named TOV-E) has been running since 2008 and since about 2015 it covers the entire country with about 500 sampling locations á 500 × 500 m., spread randomly across the area, and thus covering all ecosystem. We use this data to create four thematic bird indices, all using the same methodological approach. Using set criteria, bird species are categorised as belonging to one and only one main ecosystem. For each of our target ecosystem we extract monitoring data for these habitat specific species, and as long as there is sufficient data for that species we estimate a temporal trend for the change is population size. This means we are excluding rare and geographically restricted species, and focus on relatively common species. The trends are centered on a baseline year and all results are reported as percentage change relative to this year. We use 2015 as the reference year because at that time the bird monitoring had good national coverage in Norway, and the baseline estimate is therefore relatively robust. After we combine all the species for the same ecosystem into a muli-species index (MSI). The MSI should idealy be interpretted as time series, i.e. by looking at line graphs, but for reporting in standardised ecosystem accounting tables we have chosen to represent each three year accounting period by taking the mean of the MSI for those three years. The value represents a change relative to year 2015.

## 2. About the underlying data

<!--# Describe the data you have used in more detail, it's origin, biases, availabilit ect.-->

Dictionary:

PECBMS: [Pan European Bird Monitoring Scheme](https://pecbms.info/)

TRIM: [TRends and Indices for Monitoring data (TRIM)](https://pecbms.info/methods/software/trim/) is a freeware program developed by Statistics Netherlands in the framework of wildlife statistics

RTRIM: A set of three R script used for doing TRIM analyses. Versions exist for execution in shell and in R. See [here](https://pecbms.info/methods/software/trim/)

TOV-E: the old name for the common breeding bird monitoring program in Norway (called *Hekkefulgovervåkingen* in norwegian)

RSWAN: A tool for combining TRIM output data.

MSI: Multi-species index

### 2.1 Spatial and temporal resolution and extent

As per now, the breeding bird indicators are calculated at the national scale only and the data are therefore not linked to any geofiles here. We note that some species may be sufficiently common and have enough data to allow for calculating indicator values for two major regions, Northern Norway and Southern Norway, but this requires careful evaluation that needs to be planned and organized as part of a future project.

### 2.2 Original units

<!--# What are the original units for the most relevant  variables in the data-->

### 2.3 Additional comments about the dataset

<!--# Text here -->

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

```{=html}
<!--# 

Describe the rationale for assigning the indicator to the ECT class. See https://oneecosystem.pensoft.net/article/58218/
This doesnt need to be very long. Maybe just a single sentence. 

-->
```

### 3.2 Ecosystem condition characteristic

```{=html}
<!--# 

Describe the ecosystem condition characteristic represented in the indicator. See 10.3897/oneeco.6.e58218 for information on what these characteristics might be.
For example, and indicator called 'Trenching in mires' could be made to represent an ecosystem characteristic 'Intact hydrology'. The term 'characteristic' is used similar to the term 'criteria' in Multiple Criteria Decition Making.  

-->
```

### 3.3 Other standards

<!--# Optional: Add text about other spesific standards, e.g. national standards, and how the indicator relates to these -->

### 3.4 Collinearities with other indicators

<!--# Describe known collinearities with other metrices (indicators or variables) that could become problematic if they were also included in the same Ecosystem Condition Assessment as the indicator described here. -->

### 3.5 Impact factors

<!--# Describe the main natural and anthropogenic factors that affecst the metric -->

## 4. Reference condition and levels

### 4.1 Reference condition

<!--# Define the reference condition (or refer to where it is defined). Note the destinction between reference condition and reference levels 10.3897/oneeco.5.e58216  -->

### 4.2 Reference levels

```{=html}
<!--# 

If relevant (i.e. if you have normalised a variable), describe the reference levels used to normalise the variable. 

Use the terminology where X~0~ referes to the referece level (the variable value) denoting the worst possible condition; X~100~denotes the optimum or best possible condition; and X~*n*~, where in is between 0 and 100, denotes any other anchoring points linking the variable scale to the indicator scale (e.g. the threshold value between good and bad condition X~60^). 

Why was the current option chosen and how were the reference levels quantified? If the reference values are calculated as part of the analyses further down, please repeat the main information here.

 -->
```

#### 4.2.1 Spatial resolution and validity

```{=html}
<!--# 

Describe the spatial resolution of the reference levels. E.g. is it defined as a fixed value for all areas, or does it vary. Also, at what spatial scale are the reference levels valid? For example, if the reference levels have a regional resolution (varies between regions), it might mean that it is only valid and correct to use for normalising local variable values that are first aggregated to regional scale. However, sometimes the reference levels are insensitive to this and can be used to scale variables at the local (e.g. plot) scale. 

 -->
```

## 5. Uncertainties

<!--# Describe the main uncertainties or sources of error in the indicator or the underlying data. -->

## 6. References

<!--# You can add references manually or use a citation manager and add intext citations as with crossreferencing and hyperlinks. See https://quarto.org/docs/authoring/footnotes-and-citations.html -->

::: {#refs}
:::

## 7. Datasets

<!--# Describe the unique datasets seperately under seperate headers (Dataset A, Dataset B, etc.-->

### 7.1 Dataset A

<!--# Describe the main dataset, typicaly the one containing the variable of (most) interest. Change the header from Dataset A to the name of the actuall dataset. -->

### 7.2. Dataset B

<!--# Describe additional datasets in a similar was as above. Deleteor add ned subheaders as needed. -->

## 8. Spatial units

```{=html}
<!--# 

Describe the spatial units that you rely on in your analyses. Highlight the spatial units (the resolution) that the indicator values should be interpretted at. Potential spatial delineation data should eb introduced under 7.1. Datasets. We recomend using the SEEA EA terminology opf Basic Spatial Units (BSU), Ecosystem Asses (EA) and Ecosystem Accounting Area (EAA). 

-->
```

## 9. Analyses

### Workflow setup {#sec-workflow}

The code for the following analyses has been developed in a separate GitHub repository: https://github.com/NINAnor/birdIndicators As a first step, we therefore need to read in all the functions from that repository. The repository has not been converted into a package yet, so we need to download the entire repository and source all function files in the “R” folder manually:

```{r}
#| eval: false
#| code-summary: "Download functions from GitHub repository"
temppath <- here::here("indicators/NO_BIRD_001-004/temp")
destpath <- paste0(temppath, "/birdIndicators_Repo.zip")

# download.file(url = "https://github.com/NINAnor/birdIndicators/archive/refs/heads/main.zip",
#              destfile = destpath)
# unzip(zipfile = destpath,
#      exdir = temppath)

sourceDir <- function(path, trace = TRUE, ...) {
  for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
    if(trace) cat(nm,":")
    source(file.path(path, nm), ...)
    if(trace) cat("\n")
  }
  invisible()
}
sourceDir(paste0(temppath, "/birdIndicators-main/R"))
```

Next, we need to define a range of relative and absolute directories. The main reason for that is that many of the scripts delivered by PECBMS function by iteratively writing and reading files in a specific folder structure. We use `here::here()` to go from relative to absolute paths. While all code would ideally be rewritten to work with relative paths and without toggling working directories, PECBMS tends to distribute new versions of their scripts periodically and with no formal version control in place. This means that it is imperative to leave their core code as untouched as possible to facilitate including new versions (by copy paste) as they come.

```{r}
#| code-summary: "Create local directories"
## Absolute path for root folder:
wd <- here::here("indicators/NO_BIRD_001-004")

# Storage of raw PECBMS Trim outputs
folder <- paste0(wd, "/PECBMS_Files")

# Storage of processed PECBMS Trim outputs
subFolderName <- "Species_files"

# general and working folders
 general_folder_rel <- paste0(wd, "/temp/birdIndicators-main/data")
 working_folder_rel <- paste0(folder, "/", subFolderName)

# Storage of MSI results
MSI_results_folder <- paste0(wd, "/MSI_Results")

# NINAs local storage of legacy Trim output files
legacyFile_folder <- "P:/41201612_naturindeks_2021_2023_database_og_innsynslosning/Hekkefugl_Dataflyt/LegacyFiles_PECBMS_Trim"

# Absolute data and output paths for RSWAN (not needed)
# general_folder <- general_folder_rel
# working_folder <- working_folder_rel
# output_folder <- paste0(working_folder, "/output/") 
# output_folder2 <- paste0(working_folder, "/output") 


## Create directories if they are not available
dir.list <- c(
  folder, 
  general_folder_rel, 
  working_folder_rel
  )

for(i in 1:length(dir.list)){
  if(!file.exists(dir.list[i])){ 
  dir.create(dir.list[i])
  }
}

```

### Data sets

The workflow uses the up-to-date raw data from “hekkefuglovervåking”. One can also combine this with the calculated abundance indices from the predecessor monitoring scheme in Norway, and that way get a longer time series, but we will not do that here. Additionally, we also use a couple of lists holding information on which species (and years) are to be included in which parts of the analytical workflow as the different outcomes require different information.

### Monitoring data from “Hekkefuglovervåking” {#sec-download}

The route-based raw data from “hekkefuglovervåking” are compiled after each breeding season and curated and stored in NINA’s database. Before storing new data in the database, a thorough quality-check is performed. From that database we download the data relevant for the [PECBMS Trim analyses](https://pecbms.info/methods/software/trim/)and for the specified range of years (here from 2008 up to and including 2024). The function `downloadData_TRIM` does that for a specified year range (from minYear up to and including maxYear), and requires specifying which driver is used for accessing the database (via argument DriverName). When running from the NINA RStudio server, we need to use “FreeTDS”. When running locally from NINA computers, we need to select “SQL Server”. Note that downloading these data requires user-specific access privileges which can be requested from NINA IT department (‘datahjelp’).

```{r}
#| eval: false
#| code-summary: "Download Trim data from NINA database"
minYear <- 2008
maxYear <- 2024

Trim_data <- downloadData_TRIM(
  minYear = minYear, 
  maxYear = maxYear,
  drop_negativeSpp = TRUE, 
  # DriverName = "FreeTDS"
  DriverName = "SQL Server"
  )
# save temp file
saveRDS(Trim_data, file = paste0(wd, "/temp/Trim_data.rds"))
```

```{r}
#| include: false
Trim_data <- readRDS(paste0(wd, "/temp/Trim_data.rds"))
```

### Lists of species information

The species list files should have been downloaded together with the rest of the birdIndicators repository (@sec-workflow) and we can use `makeSpeciesLists()` to assemble the information.

```{r}
#| eval: false	
#| code-summary: "Assemble species lists"
sppLists <- makeSpeciesLists(
  Trim_data = Trim_data, 
  spp_DataPath = paste0(wd, "/temp/birdIndicators-main/data"))
Spp_selection <- sppLists$sppData

# save data
saveRDS(sppLists, file = paste0(wd, "/data/sppLists.rds"))
saveRDS(Spp_selection, file = paste0(wd, "/data/Spp_selection.rds"))
```

```{r}
#| echo: false
sppLists <- readRDS(paste0(wd, "/data/sppLists.rds"))
Spp_selection <- readRDS(paste0(wd, "/data/Spp_selection.rds"))
```

The table `Spp_selection` contains information for each species on which reporting routes should be included in. The multi-species indices are grouped into a single category (“MSI”) here, but we can extract the species that go into the MSI for each ecosystem via the additionally provided lists.

::: {layout-ncol="2"}

Farmland MSI species:

```{r}
#| echo: false
#| results: asis
temp <- sort(Spp_selection$Species[which(Spp_selection$EURINGCode %in% sppLists$sppLists$MSI_farmland)])
cat(paste0("- ", temp), sep = "\n")
```

Forest MSI species:

```{r}
#| echo: false
#| results: asis
temp <- sort(Spp_selection$Species[which(Spp_selection$EURINGCode %in% sppLists$sppLists$MSI_forest)])
cat(paste0("- ", temp), sep = "\n")
```

Mountain MSI species:

```{r}
#| echo: false
#| results: asis
temp <- sort(Spp_selection$Species[which(Spp_selection$EURINGCode %in% sppLists$sppLists$MSI_mountain)])
cat(paste0("- ", temp), sep = "\n")
```

Wetlands MSI species:

```{r}
#| echo: false
#| results: asis
temp <- sort(Spp_selection$Species[which(Spp_selection$EURINGCode %in% sppLists$sppLists$MSI_wetlands)])
cat(paste0("- ", temp), sep = "\n")
```

:::

### PECBMS RTRIM analyses

In the next step, the downloaded raw data (see @sec-download) is analysed and converted into species-specific abundance indices using the RTRIM approach ("**TR**ends and **I**ndices for **M**onitoring data" [@R-rtrim2020]). The RTRIM analyses are run for a subset of 85 species which have sufficient data for it using the standardized scripts provided by PECBMS (more information on https://pecbms.info/methods/software/trim/). For the application here, we have written wrapper function around the PECBMS code for each step of the RTRIM workflow.

```{r}
#| eval: false
#| code-summary: "TRIM analyses"

# Write PECBMS arguments input files for each species
# These are called *_arg_input_stratum under PECBMS_Files
argument_file <- 
  setupInputFiles_PECBMS_trimShell(
    Spp_selection = Spp_selection,
    folderPath = folder)

## Subset data to contain only relevant species
PECBMS_data <- 
  makeInputData_PECBMS(
    Trim_data = Trim_data,
    Spp_selection = Spp_selection,
    convertNA = TRUE, 
    save_allSppData = TRUE, 
    returnData = TRUE,
    wd = wd)

## Run analyses using the PECBMS Rtrim shell
runRtrimShell_PECBMS(folder = folder)

## Process results
# Returns file called all_Indices_All_Trends in PECBMS_Files
trimResults_PECBMS <- processRtrimOutput_PECBMS(folder = folder)
```

The results of the the RTRIM workflow are a series of .csv and .txt files. Here we copied hem into a designated folder:

```{r}
#| eval: false
#| code-summary: "Copy and rename files files"
## Collect (and rename) species and summary files
collectSpeciesFiles_PECBMS(
  folder = folder, 
  subFolderName = subFolderName)
```

### Aggregation to multi-species indices (MSIs)

The breeding bird indicators for ecosystem condition accounts / assessments are multi-species indices (MSIs) calculated following the guidelines from PECBMS (https://www.cbs.nl/en-gb/society/nature-and-environment/indices-and-trends--trim--/msi-tool) and using the algorithm of @soldaat2017.

The function for calculating MSIs requires specifying whether or not to make use of combined time series generated by RSWAN (argument `useCombTS`), which year to use as a base/reference (argument `baseYear`), and which year to use as a changepoint (argument `changepointYear`).

We are not including data from the bird monitoring that was in effect before the current *Hekkefulgovervåkinga*, and therefore we do not need to use the RSWAM method to combine time series.

We set the base year to be 2015 to coincide with the time when the bird monitoring became truly national in coverage. The baseline year only works to center the time series around a fixed time. The relative change in the time series remains unchanged. The use of arbitrary baseline years (arbitrary in the sense that they do not represent a reference state in the SEEA EA use of the term, or any other necessarily desirable value) means that point estimates should really be interpreted with caution when seen in isolation. It is the development of the trends in the time series that is important to understand and convey. But having a spatially representative baseline means there is less chance of a spatial bias in the sampling to affect the absolute level of the time time series, but as we have explained, the temporal trends are unaffected.

The choice of change point year does not affect index values, but specifies until and from which year additional, shorter term trends should be calculated (i.e. if `changepointYear = 2008`, the procedure will additionally provide trend estimates from starting year to 2008, and from 2008 to the last year in the data). We set this to 2022 below because we have to set something, but we will not investigate this part of the analyses any further.

```{r}
#| code-fold: false
useCombTS <- FALSE
baseYear <- 2015
changepointYear <- 2022
```

The function also requires us to provide a name (argument) and a list of EURING codes of species to include (argument). We list these for all four ecosystem indices:

```{r, eval = FALSE}
IndexNames <- c("FarmlandBirds", "ForestBirds", "MountainBirds", "WetlandBirds")
Index_sppLists <- list(sppLists$sppLists$MSI_farmland,
                       sppLists$sppLists$MSI_forest,
                       sppLists$sppLists$MSI_mountain,
                       sppLists$sppLists$MSI_wetlands)
```

We will calculate all four indices starting from whenever the data starts (2008) and using 2015 as the reference year.

```{r}
#| eval: false
#| code-summary: "Calculate MSI values"
MSI_longTerm <- data.frame()

for(i in 1:4){
  message(paste0(crayon::bold("Calculating ", IndexNames[i], " Index...")))
  results <- calculateIndex_MultiSpecies(working_folder = working_folder_rel, 
                                         Spp_subset = Index_sppLists[[i]], 
                                         IndexName = IndexNames[i], 
                                         results_folder = MSI_results_folder,
                                         useCombTS = useCombTS,
                                         baseYear = baseYear,
                                         changepointYear = changepointYear)
  MSI_longTerm <- rbind(MSI_longTerm, results)
  message("")
}
# save output
saveRDS(MSI_longTerm, file = paste0(wd, "/data/MSI_results.rds"))
```

```{r, echo = FALSE}
MSI_results <- readRDS(paste0(wd,"/data/MSI_results.rds"))
```

The MSI is provided both as point estimates (`MSI`) with associated standard error (`sd_MSI`) and confidence interval (`lower_CL_MSI` and `upper_CL_MSI`), and as a smoothed trend model fit (characterised by an average trend, `Trend`, and an associated confidence interval, `lower_CL_trend` and `upper_CL_trend`):

Additionally, the results are saved as a standardized set of files used for reporting to PECBMS.

We can now visualize the results both as point estimates and trend fit:

```{r fig-MSI2015}
#| fig-cap: 'Time series of the multispecies indices (MSIs) for the all ecosystems. The trend is centered to equal 100% in year 2015.'

myplotTimeSeries_MSI <- function(MSI, results_folder){
  
  ## Define custom colors
  plotCols <- colorspace::divergingx_hcl(palette = "Temps", n = length(unique(MSI$IndexName)))
  
  p2 <- ggplot(MSI, aes(x = year, y = MSI)) + 
    geom_point(aes(colour = IndexName), size = 3) + 
    geom_pointrange(aes(ymin = MSI - sd_MSI, ymax = MSI + sd_MSI, colour = IndexName)) + 
    geom_line(aes(y = Trend, colour = IndexName), linetype = "dashed") +
    geom_ribbon(aes(ymin = lower_CL_trend, ymax = upper_CL_trend, fill = IndexName), alpha = 0.2) + 
    scale_x_continuous(name = "Year", breaks = min(MSI$year):max(MSI$year)) + 
    scale_color_manual(name = "Index", values = plotCols) +
    scale_fill_manual(name = "Index", values = plotCols) + 
    ylab("MSI Value (% of baseline)") + 
    theme_bw() + 
    theme(panel.grid.minor = element_blank(),
          axis.text.x = element_text(angle = 45, hjust = 1)) 
  
    print(p2)
  }
  


myplotTimeSeries_MSI(
  MSI = MSI_results,
  results_folder = MSI_results_folder
                   )
```

### Choise of metric to represent accounting period

The MSI should ideally be interpreted as time series (e.g. from looking at @fig-MSI2015). However, ecosystem accounting tables are limited in how they can convey temporal trends. Usually this is limited to a starting and closing value. The value for a gives year (point estimates) can fluctuate due to natural variation (e.g. weather events) and may not reflect any long or medium term trend in ecosystem condition. The MSI trend is better at smoothing out these interannual trends. However, it may be too good at smoothing out these trends, and we want to avoid data from previous accounting periods to affect subsequent periods. Our solution is to use the mean of the MSI point estimates from the years inside each accounting period (three year periods). Errors are aggregated by simulating values for each time step. assuming a normal distribution, and sampling equally from each. We must stress that the absolute variable value for an accounting period is only interprettable as a short term trend in the data, and to not indicate whether this value is especial high or low compared to historical values or any desirable state.

> We must stress that the absolute variable value for an accounting period is only interprettable as a short term trend in the data, and to not indicate whether this value is especial high or low compared to historical values or any desirable state.

These bird indices are variables in the SEEA EA terminology and should be reported in the variable account.

## 10. Results


```{r}
#| message: false
output <- MSI_results |>
  
# errors are 0 in 2015 so we will not use that year, or any year before, at least not for this excercise
  filter(year > 2015) |> 

# creating three accounting periods
  mutate(accounting_period_final_year = case_when(
    year <= 2018 ~ 2018,
    year <= 2021 ~ 2021,
    year <= 2024 ~ 2024,
    .default = NA
      )) |>
  mutate(accounting_period = case_when(
    year <= 2018 ~ "2016-2018",
    year <= 2021 ~ "2019-2021",
    year <= 2024 ~ "2022-2024",
    .default = NA
      )) |>

# create probability distributions for each point estimate, 
# assuming a normal distribution
  rowwise() |>
  mutate(
    dist = list(rnorm(10000, MSI, sd_MSI))) |>

# sample 9000 observations randomly across the three years 
# inside each accountin period to get a shared distribution
  group_by(IndexName, accounting_period_final_year, accounting_period) |>
    reframe(
      variableValue = mean(MSI),
      dist = list(sample(
        unlist(dist),
        size = 9000,
        replace = TRUE))) |>

# get the 25th and 75th percentile from this shared distribution
  ungroup() |>
  rowwise() |>
  mutate(
    "75th percentile" = quantile(unlist(dist), 0.75),    # ERROR 
    "25th percentile" = quantile(unlist(dist), 0.25), 
  
 # Add some variables for the final table 
    ID = case_when(
      IndexName == "FarmlandBirds" ~ "NO_BIRD_001",
      IndexName == "ForestBirds" ~ "NO_BIRD_004",
      IndexName == "MountainBirds" ~ "NO_BIRD_002",
      IndexName == "WetlandBirds" ~ "NO_BIRD_003"
    ),
    ecosystem = case_when(
      IndexName == "FarmlandBirds" ~ "Farmland & Open lowland",
      IndexName == "ForestBirds" ~ "Forests",
      IndexName == "MountainBirds" ~ "Alpine",
      IndexName == "WetlandBirds" ~ "Wetlands"
    )) |>
  add_column(
    ECT = "B1",
    "Accounting area" = "Norway") |>

# Select which columns to show, and set their order
  select(
    Indicator = IndexName, 
    ID, 
    ECT, 
    "Accounting area",
    "Accounting period" = accounting_period,
    "Variable value" = variableValue,  
    "25th percentile",  
    "75th percentile")

# print table
output |>
    kbl()

```
